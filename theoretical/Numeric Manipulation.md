## complement
보수는 두 양수 이진수의 뺄셈에서 음수 역할을 하는 수다.
- 뺄셈 (a - b)을 덧셈 (a + c)으로 만든다.
- c가 보수이며 (-b)의 역할을 한다.  
다만 -부호를 가진 값이 아니라, +부호를 가지고 음수의 역할을 하는 것이다.  
실제 signed integer 표현은 MSB를 sign 비트로 사용하고, 크기 부분은 양수와 음수가 동일하다.  
(sign 비트의 값은 양수는 0이고 음수는 1이다.)

> 다른 덧셈 및 뺄셈 경우의 수는 보수를 이용할 필요가 없다.
> - 두 양수의 덧셈은 그냥 더하면 된다.
> - 두 음수의 덧셈은 부호를 무시하고 더한 후, -부호를 붙이면 된다.

#### ones' complement
1의 보수는 각 비트를 반전시켜서 만든다. (직역하면 1들의 보수다.)  
보수를 구하는 것은 간단하지만 뺄셈이 복잡하다.
##### 보수
- 0000 0111 (7)
- 1111 1000 (-7)
##### 뺄셈
case 1. MSB에서 자리올림이 발생한 경우: 뺄셈 결과가 양수다.  
예시) 8 - 7 = 1
```
step 1. 빼는 수의 1의 보수.
위에서 구했듯이 -7은 1111 1000이다.

step 2. 덧셈으로 계산: 8 + (-7)
  0000 1000 (8)
+ 1111 1000 (-7)
-----------------
 10000 0000

step 3. 최종 뺄셈 결과: 위 결과의 LSB에 1을 더한다.
  0000 0001 (1: 결과)
```

case 2. MSB에서 자리올림이 발생하지 않는 경우: 뺄셈 결과가 0 또는 음수인 경우  
예시) 7 - 7 = 0
```
step 1. 빼는 수의 1의 보수.
위에서 구했듯이 -7은 1111 1000이다.

step 2.덧셈으로 계산: 7 + (-7)
  0000 0111 (7)
+ 1111 1000 (-7)
-----------------
  1111 1111

step 3. 최종 뺄셈 결과: 위 결과의 1의 보수를 구하고 - 부호를 붙인다.
 -0000 0000 (-0: 결과)
```

#### two's complement
2의 보수는 2<sup>N</sup>에서 원래 수를 뺀 값이다. (N은 총 비트수)  
실질적인 방법은 1들의 보수를 구하고 LSB에 1을 더해서 얻는다.  
MSB에서의 자리올림을 무시하므로 뺄셈이 간단하다.
##### 보수
- 0000 0111 (7)
- 1111 1000 (1의 보수)
- 1111 1001 (2의 보수)
##### 뺄셈
그냥 더하고, MSB를 넘어가는 것은 무시한다.
```
  0000 1000 (8)
+ 1111 1001 (-7)
-----------------
 10000 0001
->0000 0001 (1)
```

## extension
#### zero extension
영의 확장은 비부호형 수를 더 큰 자료형으로 변환할 때, 앞에 0을 추가하는 것이다.
#### sign extension
부호 확장은 2의 보수를 더 큰 자료형으로 변환할 때, MSB를 추가되는 비트들에 복사하는 것이다.
- 8비트에서 1에 대한 2의 보수: 1111 1111 (-1)
- 16비트로 부호 확장: 1111 1111 1111 1111 (MSB인 1로 채워넣음)
